## - 什么是泛型
**泛型代表的是任何类型**，可以是 number，string 等等，用任意字母代替，在使用时传入具体的类型，提高代码的重用型

例如：创建一个函数让它的返回值的类型与传入参数的类型一致
```ts
function test<T>(arg: T): T {
	return arg;
}
```
我们创建了泛型T，它此时可以代表任何类型，参数类型也为泛型 T，最后函数的返回值也为 泛型T，这样传入的参数类型与函数返回的类型是一致的

现在我们使用该函数，并给泛型确定的类型
```ts
// 方式一： 不明确指定泛型类型，让ts自动推断类型
test(123);

// 方式二：给泛型指定具体的类型
test<string>('hello world');
```
方式一我们传入 number 类型参数，ts会自动将 泛型T 约束为 number 类型，此时函数返回值也被要求为 number 类型;
方式二我们为 泛型T 传入具体类型 string，此时函数参数类型要求为 string，函数返回值类型要求为 string;

```ad-tip
记住：泛型代表的是任意类型！在使用时才要求传入具体的类型
```

## - 使用泛型的注意项
我们需要时刻注意**泛型代表的是任何类型**，而不同的类型含有不同的方法，看下面的例子：
```ts
function test<T>(arg: T): T {
	console.log(arg.length); // 错误
	return arg;
}
```
上面的例子会出现问题，因为**泛型代表的是任何类型**，它可以是string, 也可以是 number，而 number 是没有 length 属性的；

## - 泛型数组
我们可以使用泛型创建数组，同时因为数组有 length 属性，因而使用 length 属性不会报错
```ts
// 方式一
function test<T>(arg: T[]): T[] {
	console.log(arg.length);
	return arg;
}

// 方式二
function test<T>(arg: Array<T>): Array<T> {
	console.log(arg.length);
	return arg;
}
```

## - 泛型函数与接口
使用泛型函数的代码如下：
```ts
const test: <T>(arg: T) => T = (arg) => arg
```

我们可以使用泛型定义接口函数:
```ts
interface test {
    <T>(arg: T): T
}
```

将泛型参数作为接口参数
```ts
interface test<T> {
    (arg: T): T
}
const t: test<string> = (arg) => arg;
t('123');
```

